<?xml version="1.0" encoding="utf-8"?>

<mx:Canvas width="100%"
           height="100%"
           horizontalScrollPolicy="off"
           verticalScrollPolicy="off"
           styleName="tintorettoBackground"
           implements="ro.ciacob.desktop.windows.IWindowContent"
           xmlns:fx="http://ns.adobe.com/mxml/2009"
           xmlns:s="library://ns.adobe.com/flex/spark"
           xmlns:mx="library://ns.adobe.com/flex/mx"
           xmlns:components="eu.claudius.iacob.ui.components.*"
           xmlns:ui="eu.claudius.iacob.desktop.presetmanager.ui.*"
           preinitialize="_onPreinitialize (event)"
           initialize="_onInitialize (event)"
           creationComplete="_onCreationComplete (event)">
    <fx:Declarations/>

    <fx:Script>
        <![CDATA[
            import com.greensock.TweenMax;
            
            import eu.claudius.iacob.desktop.presetmanager.lib.PresetEvent;
            import eu.claudius.iacob.maidens.Colors;
            import eu.claudius.iacob.maidens.Sizes;
            import eu.claudius.iacob.maidens.constants.ViewKeys;
            import eu.claudius.iacob.ui.components.Constants;
            import eu.claudius.iacob.ui.components.ParameterChangeEvent;
            
            import mx.events.FlexEvent;
            import mx.utils.ObjectProxy;
            
            import ro.ciacob.desktop.data.exporters.PlainObjectExporter;
            import ro.ciacob.desktop.data.importers.PlainObjectImporter;
            import ro.ciacob.desktop.signals.PTT;
            import ro.ciacob.desktop.ui.UiFlexBuilder;
            import ro.ciacob.desktop.ui.UiGenerator;
            import ro.ciacob.desktop.ui.utils.Objects;
            import ro.ciacob.desktop.windows.IWindowsManager;
            import ro.ciacob.desktop.windows.WindowContentBehavior;
            import ro.ciacob.maidens.generators.constants.GeneratorKeys;
            
            import ro.ciacob.maidens.generators.core.constants.CoreOperationKeys;
            import ro.ciacob.maidens.generators.core.interfaces.IParameter;
            import ro.ciacob.maidens.generators.core.interfaces.IParametersList;
            import ro.ciacob.maidens.generators.core.ui.ParameterUI;
            import ro.ciacob.maidens.generators.core.ui.PointTools;
            import ro.ciacob.maidens.legacy.ProjectData;
            import ro.ciacob.maidens.legacy.constants.DataFields;
            
            import ro.ciacob.utils.ScreenUtils;
            import ro.ciacob.utils.Time;
            import eu.claudius.iacob.maidens.Colors;
            import eu.claudius.iacob.maidens.Sizes;
            import eu.claudius.iacob.EmbeddedFontsHelper;
            
            // --------------
            // PUBLIC METHODS
            // --------------
            
            /**
             * Executed by the ClassFactory upon initializing this class. Injects default data to populate the UI with.
             */
            public function set genCfgWindowData(data:Object):void {
            
                // Grab new values
                _uiBlueprint = (data[GeneratorKeys.GEN_CFG_UI_BLUEPRINT] as Object);
                if (_uiBlueprint != null) {
                    _parameters = _uiBlueprint[GeneratorKeys.PARAMETERS];
                    if (_parameters) {
                        _sanitizeParameters();
                    }
                    _animatedParameters = _uiBlueprint[GeneratorKeys.ANIMATED_PARAMETERS];
                    _animatedParameterUids = _uiBlueprint[GeneratorKeys.ANIMATED_PARAMETER_UIDS];
                    delete _uiBlueprint[GeneratorKeys.ANIMATED_PARAMETERS];
                    delete _uiBlueprint[GeneratorKeys.ANIMATED_PARAMETER_UIDS];
                    _uiBlueprintChanged = true;
                    invalidateProperties();
                }
            
                _receivedConfigData = data[GeneratorKeys.GEN_CFG_DATASET];
                if (_receivedConfigData != DataFields.VALUE_NOT_SET) {
                    _currentDatasetChanged = true;
                    invalidateProperties();
                }
            }
            
            /**
             * Executed by the ClassFactory upon initializing this class. Injects the name of the communication pipe to use
             * for passing messages to and from the rest of the application.
             */
            public function set pttPipeName(name:String):void {
                _pttInstance = PTT.getPipe(name);
                _pttInstance.subscribe(ViewKeys.GEN_CFG_WINDOW_CLOSING, _onWindowClosing);
            }
            
            /**
             * Returns the UID of the window owning this content. The windows manager assigns unique IDs to all windows upon creation,
             * and manipulates them by mean of these IDS. Will return `null` if the owner window has been destroyed (or, in other words,
             * `windowUid` will be `null` for orphaned content).
             * @readonly
             */
            public function get windowUid():String {
                return _windowBehavior.windowUid;
            }
            
            /**
             * Returns the screen this content is, or was displayed onto. Returns null if this content was never displayed (e.g., if the
             * windows holding this content has been created, but never shown).
             * @readonly
             */
            public function get homeScreen():Screen {
                return _windowBehavior.homeScreen;
            }
            
            /**
             * Returns the horizontal position of this content across the joined space of all screens in use. For instance, it will return
             * `1920` for a content held by a window which is placed at (0, 0) on the second monitor on the right, on a two, side-by-side
             * Full HD monitors setup. The offset of the window chrome, if any, is also taken into account. Returns `NaN` for orphaned content
             * (content not assigned to a window, or assigned to a window that has been destroyed meanwhile).
             * @readonly
             */
            public function get allScreensX():Number {
                return _windowBehavior.allScreensX;
            }
            
            /**
             * @see `allScreensX`
             * @readonly
             */
            public function get allScreensY():Number {
                return _windowBehavior.allScreensY;
            }
            
            /**
             * Returns the horizontal position of this content within the screen its left boundary is laid on. For instance, it will return
             * `0` (rather than `1920`) for a content held by a window which is placed at (0, 0) on the second monitor on the right,
             * on a two, side-by-side Full HD monitors setup. The offset of the window chrome, if any, is also taken into account.
             *  Returns `NaN` for orphaned content (content not assigned to a window, or assigned to a window that has been destroyed meanwhile).
             * @readonly
             */
            public function get currentScreensX():Number {
                return _windowBehavior.currentScreensX;
            }
            
            /**
             * @see `currentScreensX`
             * @readonly
             */
            public function get currentScreensY():Number {
                return _windowBehavior.currentScreensY;
            }
            
            /**
             * Sends an instance of the windows manager owner into this implementor (required for performing
             * various calculations).
             */
            public function set manager(value:IWindowsManager):void {
                _windowBehavior.manager = value;
            }
            
            /**
             * Retrieves the windows manager instance previously sent into this implementor.
             */
            public function get manager():IWindowsManager {
                return _windowBehavior.manager;
            }
            
            /**
             * Produces a simple ValueObject with the initial values of the generated UI
             * controls. These may be default values, or values previously saved on "this"
             * particular Generator instance.
             *
             * We will consider these "factory defaults" as the "reference dataset"
             * to observe any future changes against, and this method provides us precisely this
             * list of factory defaults.
             */
            private function _extractDefaultsFromUi(uiDescriptor:Object):Object {
                var ret:Object = {};
                var key:String;
                var param:IParameter;
                for (key in uiDescriptor) {
                    if (key == GeneratorKeys.UI_GENERATOR_CONFIG) {
                        continue;
                    }
                    param = _parameters.getByUid(key);
                    ret[param.name] = param.payload;
                }
                return ret;
            }
            
            // -----------------
            // PROTECTED METHODS
            // -----------------
            
            /**
             * Processes the properties set on the component.
             * @see UIComponent.commitProperties()
             */
            override protected function commitProperties():void {
                super.commitProperties();
                if (_uiBlueprintChanged) {
                    _uiBlueprintChanged = false;
                    _buildUi();
            
                    // We need populate the UI after building it
                    _currentDatasetChanged = true;
                    if (_receivedConfigData == DataFields.VALUE_NOT_SET) {
                        _receivedConfigData = {content: _extractDefaultsFromUi(_uiBlueprint)};
                    }
                }
            
                if (_currentDatasetChanged) {
                    _currentDatasetChanged = false;
                    _currentDataset = new ProjectData;
                    if (_receivedConfigData) {
                        var importer:PlainObjectImporter = new PlainObjectImporter;
                        importer.importData(_receivedConfigData, _currentDataset);
                    }
            
                    // The loaded dataset will become our new reference, overwriting the default
                    // dataset.
                    _referenceDataset = ProjectData(_currentDataset.clone());
                }
            }
            
            // -----------------
            // PRIVATE CONSTANTS
            // -----------------
            private static const SUBSCRIBE:Function = PTT.getPipe().subscribe;
            
            private static const EDITOR_SERVICE:String = CoreOperationKeys.EDITOR_SERVICE_NOTICE;
            private static const EDITOR_FOCUS:String = CoreOperationKeys.EDITOR_FOCUS_NOTICE;
            private static const PARAM_UID:String = CoreOperationKeys.PARAM_UID;
            private static const TWEENING_STATUS:String = CoreOperationKeys.TWEENING_STATUS;
            private static const TYPE_ARRAY:uint = CoreOperationKeys.TYPE_ARRAY;
            private static const DATA_ITEM:String = Constants.DATA_ITEM;
            private static const NODE_TIME:String = Constants.NODE_TIME;
            private static const NODE_AMPLITUDE:String = Constants.NODE_AMPLITUDE;
            private static const INLINE_DOC_SHOW:String = CoreOperationKeys.INLINE_DOC_REQUESTED_NOTICE;
            private static const INLINE_DOC_HIDE:String = CoreOperationKeys.INLINE_DOC_DISCARDED_NOTICE;
            private static const DOCUMENTATION:String = CoreOperationKeys.DOC_REQUESTED_NOTICE;
            private static const PARAM_NAME:String = CoreOperationKeys.PARAM_NAME;
            private static const DESCRIPTION:String = CoreOperationKeys.DOCUMENTATION_DESCRIPTION;
            private static const URL:String = CoreOperationKeys.DOCUMENTATION_URL;
            
            private static const SPACE:Number = 10;
            private static const PRESET_FILE_EXTENSION:String = 'harmonyPreset';
            private static const PRESETS_HOME_DIR:String = 'multiline-generator-preset';
            private static const COLUMN_WIDTH:Number = (Sizes.MIN_GEN_CFG_WINDOW_BOUNDS.width - SPACE * 2);
            
            // -----------------
            // PRIVATE VARIABLES
            // -----------------
            
            // The proxy providing window related functionality to this UIComponent
            private var _windowBehavior:WindowContentBehavior;
            
            // The communication pipe to use
            private var _pttInstance:PTT;
            
            // The dataset representing the information made available to the user
            // by means of this UI. The user can freely alter this dataset.
            private var _currentDataset:ProjectData;
            
            // Detached copy of the `_currentDataset`, inaccessible to the user. Used
            // to determine whether the user actually performed any changes.
            private var _referenceDataset:ProjectData;
            
            // An Object describing the UI to be dynamically built. Injected by the ClassFactory
            // upon initializing this class. The data in this Object follows the guidelines in the
            // UIBuilder library specifications.
            private var _uiBlueprint:Object;
            
            // Flag that we raise when we have new data stored in `_uiBlueprint`. This flag will be
            // picked up in the next drawing cycle of the component.
            private var _uiBlueprintChanged:Boolean;
            
            // An Object containing values to populate the dynamically built UI with.
            private var _receivedConfigData:Object;
            
            // Flag that we raise when we have new data stored in either `_receivedConfigData`
            // or `_uiBlueprint`. The idea is that we can infer our current dataset either from values
            // explicitly received, or from the defaults found in the UI descriptor (aka "blueprint").
            private var _currentDatasetChanged:Boolean;
            
            // The UiGenerator used to dynamically build this component's UI, based on received blueprint
            private var _uiGenerator:UiGenerator;
            
            // Full list of parameters supported by this Generator. Each parameter is represented by an
            // IParameter instance.
            private var _parameters:IParametersList;
            
            // Map with all Array typed parameters that currently employ tweening
            private var _animatedParameters:Object = {};
            
            // Ordered list with all the UIDs in the `_animatedParameters` map
            private var _animatedParameterUids:Array = [];
            
            // Flag we raise to indicate that the Envelope Editor should be included in the UI
            [Bindable]
            private var _envelopeEditorVisible:Boolean = false;
            
            // Flag we raise when all parameter items have been fully rendered as form controls
            [Bindable]
            private var _formReady:Boolean = false;
            
            // Stores the UID of the tweenable parameter that is currently active/editable
            // inside the Envelope Editor
            private var _activeParamUid:String;
            
            // Maintains a map with all parameters' current values, indexed by the parameter's name
            private var _currentSettings:Object;
            
            [Bindable]
            private var _inlineDocTitle:String;
            
            [Bindable]
            private var _inlineDocBody:String;
            
            [Bindable]
            private var _inlineDocUrl:String;
            
            // ---------------
            // PRIVATE METHODS
            // ---------------
            
            /**
             * Causes/allows the window hosting this UIComponent to actually be closed.
             */
            private function _closeWindow():void {
                if (_pttInstance != null) {
                    _pttInstance.unsubscribe(ViewKeys.GEN_CFG_WINDOW_CLOSING, _onWindowClosing);
                    _pttInstance.send(ViewKeys.GEN_CFG_WINDOW_CLOSE);
                }
            }
            
            /**
             * Causes the UI portion related to warning the user about uncommitted changes to
             * change color, in order to draw attention.
             */
            private function _setNotificationAreaColor(mustWarn:Boolean):void {
                if (mustWarn) {
                    bottomBox.setStyle('backgroundColor', Colors.WARNING);
                }
                else {
                    bottomBox.clearStyle('backgroundColor');
                }
            }
            
            /**
             * Causes user changes to be sent into MAIDENS. In the process, aligns the "reference dataset",
             * the way that the altered set becomes the new reference. Also updates the UI, so that it shows
             * that there are no "new changes" anymore. Optionally closes the parent window.
             */
            private function _commitChanges():void {
                if (_pttInstance != null) {
                    var configMap:Object = _currentDataset.getContentMap();
                    ProjectData(_referenceDataset).importContent(configMap);
                    _currentDataset = ProjectData(_referenceDataset.clone());
                    var data:Object = {};
                    var exporter:PlainObjectExporter = new PlainObjectExporter;
                    var exportedCfgData:Object = exporter.export(_currentDataset);
                    data[GeneratorKeys.GEN_CFG_DATASET] = exportedCfgData;
                    _pttInstance.send(GeneratorKeys.GEN_CFG_WINDOW_COMMIT, data);
                }
                _closeWindow();
            }
            
            /**
             * Causes user changes to be lost, effectively replacing the "current dataset" with the
             * "reference dataset". Optionally closes the parent window.
             */
            private function _discardChanges():void {
                _currentDataset = ProjectData(_referenceDataset.clone());
                var mover:Function = function (parameter:IParameter, index:int, list:IParametersList):void {
                    parameter.payload = _currentDataset.getContent(parameter.name);
                };
                _parameters.forEach(mover);
                _closeWindow();
            }
            
            /**
             * Dynamically generates UI controls based on the current UI descriptor (or "blueprint").
             */
            private function _buildUi():void {
                if (_uiBlueprint) {
                    _renderParameters(_uiBlueprint, configurationForm, _onFormReady, _onValueChanged);
                }
            }
            
            /**
             * Registers parameter with given id as requiring the envelope editor's services.
             */
            private function _engageTweeningFor(parameterId:String):void {
                _animatedParameters[parameterId] = _parameters.getByUid(parameterId);
                _updateEditorWorklist();
            }
            
            /**
             * Causes the envelope associated to the given parameter's uid to be focused (displayed on top)
             * inside the editor. Does nothing if the parameter was not previously added to the editor's
             * worklist.
             */
            private function _focusParameterEnvelope(parameterId:String):void {
                if (parameterId && parametersEditor.dataProvider) {
                    var loadedParameters:Array = (parametersEditor.dataProvider.parameters as Array);
                    if (loadedParameters && loadedParameters.length) {
                        for (var i:int = 0; i < loadedParameters.length; i++) {
                            var parameter:Object = (loadedParameters[i] as Object);
                            if (parameter.paramUid == parameterId) {
                                parameter.selected = true;
                                parameter.visible = true;
                                parameter.locked = false;
                            }
                            else {
                                parameter.selected = false;
                            }
                        }
                    }
                }
            }
            
            /**
             * Notifies the preset manager of a particular change in the current settings. This causes the
             * manager to update the currently selected preset in the presets list if the current set should
             * match an existing settings combinations. This also prevents identical presets from being created.
             */
            private function _respondToSettingUpdate(settingName:String, settingValue:Object):void {
                if (!_currentSettings) {
                    _currentSettings = _readCurrentSettings();
                }
                _currentSettings[settingName] = settingValue;
                presetManager.evaluate(_currentSettings);
            }
            
            /**
             * Used in conjunction with the preset manager library, in order to retrieve (and possibly store
             * as a preset) the user's current settings.
             *
             * @return    An Object containing parameter uids as keys and their respective values as Object
             *            values.
             */
            private function _readCurrentSettings():Object {
                var output:Object = {};
            
                // Populates the `output` Object with the current value of each parameter.
                var mover:Function = function (parameter:IParameter, index:int, list:IParametersList):void {
                    output[parameter.name] = parameter.payload;
                };
            
                _parameters.forEach(mover);
                return output;
            }
            
            /**
             * Used in conjunction with the preset manager library, in order to transfer a stored preset
             * into the current settings. For both the UI and the underlying generator, this will be a
             * completely transparent process (it will be as if the user entered by hand each value stored
             * inside the preset).
             *
             * @param    settings
             *            An Object containing parameter names as keys and their respective values as Object
             *            values. This is semantically identical to the Object returned by
             *            `_readCurrentSettings()`.
             */
            private function _writeCurrentSettings(settings:Object):void {
            
                // Sets each parameter's current value to the corresponding value stored inside the `settings` Object. Note that older version presets might not hold settings for all parameters.
                var mover:Function = function (parameter:IParameter, index:int, list:IParametersList):void {
                    if (parameter.name in settings) {
                        parameter.payload = settings[parameter.name]; // !!replacing and Array payload is bad.
                        _currentDataset.setContent(parameter.name, parameter.payload);
                    }
                };
            
                _parameters.forEach(mover);
                _updateForm();
            }
            
            /**
             * Updates the existing form without rebuilding it, showing or hiding the envelope editor as needed.
             */
            private function _updateForm():void {
                if (_parameters && _parameters.length > 0) {
                    var mover:Function = function (parameter:IParameter, index:int, list:IParametersList):void {
                        var parameterUid:String = parameter.uid;
                        var renderer:ParameterUI = (_uiGenerator.getComponentByName(parameterUid) as ParameterUI);
                        if (renderer) {
                            var payload:Object = parameter.payload;
                            renderer.value = payload;
                            if (parameter.type == TYPE_ARRAY) {
                                var animatedParameterUids:Array = [];
                                var haveEditorChanges:Boolean = false;
                                if (payload && PointTools.pointsIncurTweening(payload as Array)) {
                                    animatedParameterUids.push(parameterUid);
                                    if (!(parameterUid in _animatedParameters)) {
                                        _animatedParameters[parameterUid] = parameter;
                                        haveEditorChanges = true;
                                    }
                                }
                                else {
                                    if (parameterUid in _animatedParameters) {
                                        delete _animatedParameters[parameterUid];
                                        haveEditorChanges = true;
                                    }
                                }
                                _updateEditorWorklist();
                                if (haveEditorChanges) {
                                    Time.delay(0.2, function ():void {
                                            _focusParameterEnvelope(animatedParameterUids[0]);
                                        });
                                }
                            }
                        }
                    };
            
                    _parameters.forEach(mover);
                }
            }
            
            /**
             * Rebuilds the Envelope Editor's data provider, based on the current content of the
             * `_animatedParameters` map.
             */
            private function _updateEditorWorklist():void {
                if (parametersEditor) {
                    var dataset:Object = {};
                    var parameters:Array = [];
            
                    // Transfer function, ensuring that the parameters having tweening engaged get loaded into the
                    // envelope editor in the same order as they were added inside the IParametersList instance
                    // (which is also the order they show in the UI).
                    var mover:Function = function (parameter:IParameter, index:int, list:IParametersList):void {
                        var paramId:String = parameter.uid;
                        if (paramId in _animatedParameters) {
                            var paramDataset:Object = {};
                            paramDataset[PARAM_UID] = parameter.uid;
                            paramDataset.name = parameter.name;
                            paramDataset.color = parameter.color;
                            paramDataset.visible = true;
                            paramDataset.values = (parameter.payload as Array);
                            var paramProxy:ObjectProxy = new ObjectProxy(paramDataset);
                            parameters.push(paramProxy);
                        }
                        // TODO: also transfer here the result of the last generation task (they are called "actual curves"
                        // in envelope editor's parlance, and reflect the way the generator was able to actually respond
                        // to the demands of the "ideal curve", that is, the values plotted by the user on the envelope).
                    };
            
                    _parameters.forEach(mover);
                    dataset.parameters = parameters;
                    var proxy:ObjectProxy = new ObjectProxy(dataset);
                    parametersEditor.dataProvider = proxy;
            
                    // Hide or show the editor, based on whether there are envelopes to be edited or not
                    var isEditorNeeded:Boolean = !Objects.isEmpty(_animatedParameters);
                    if (isEditorNeeded) {
                        if (!_envelopeEditorVisible) {
                            _showEnvelopeEditor();
                        }
                    }
                    else {
                        if (_envelopeEditorVisible) {
                            _hideEnvelopeEditor();
                        }
                    }
                }
            }
            
            /**
             * Displays the Envelope Editor, also enlarging the window to accommodate the new UI.
             */
            private function _showEnvelopeEditor():void {
                _envelopeEditorVisible = true;
                TweenMax.fromTo(parametersEditor, 1, {alpha: 0}, {alpha: 1});
            }
            
            /**
             * Hides the Envelope Editor, optionally shrinking the window to reclaim screen real estate.
             */
            private function _hideEnvelopeEditor():void {
                _envelopeEditorVisible = false;
            }
            
            /**
             * Unregisters a parameter previously registered with `_engageTweeningFor()`.
             */
            private function _disengageTweeningFor(parameterId:String):void {
                delete _animatedParameters[parameterId];
                _updateEditorWorklist();
            }
            
            /**
             * For every Parameter with multiple values, makes sure that these values meet the format expected
             * by the Envelope Editor. Any needed changes are operated in-place (no value is returned).
             */
            private function _sanitizeParameters():void {
                _parameters.forEach(function (parameter:IParameter, index:int, list:IParametersList):void {
                        var kind:uint = parameter.type;
                        if (kind == TYPE_ARRAY) {
                            var points:Array = (parameter.payload as Array);
                            parameter.payload = PointTools.sanitizeEnvelopePoints(points);
                        }
                    });
            }
            
            /**
             * Visually renders given parameters in given container, thus providing the user
             * the ability to set their values. Called from `_buildUi()` and `_resetForm ()`.
             */
            private function _renderParameters(descriptor:Object, target:DisplayObjectContainer, onComplete:Function, onChange:Function):void {
                _formReady = false;
            
                // This function iterates through all the parameters and collects those needing the services of the
                // envelope editor. The actual compilation of the envelope's editor data provider is handled inside the
                // "_updateEditorWorklist()" function.
                var iterator:Function = function (parameter:IParameter, index:int, list:IParametersList):void {
                    var parameterUid:String = parameter.uid;
                    var payload:Object = parameter.payload;
                    var paramIdIndex:int;
            
                    if (parameter.type == TYPE_ARRAY) {
                        if (payload && PointTools.pointsIncurTweening(payload as Array)) {
                            if (!(parameterUid in _animatedParameters)) {
                                _animatedParameters[parameterUid] = parameter;
                                paramIdIndex = _animatedParameterUids.indexOf(parameterUid);
                                if (paramIdIndex == -1) {
                                    _animatedParameterUids.push(parameterUid);
                                }
                            }
                        }
                        else {
                            if (parameterUid in _animatedParameters) {
                                delete _animatedParameters[parameterUid];
                                paramIdIndex = _animatedParameterUids.indexOf(parameterUid);
                                if (paramIdIndex != -1) {
                                    _animatedParameterUids.splice(paramIdIndex, 1);
                                }
                            }
                        }
                    }
                };
            
                // This function is executed after UI has been generated for all parameters.
                // If the envelopes editor is required, it is shown, with the first of the
                // available envelopes preselected.
                var wrapper:Function = function ():void {
                    _parameters.forEach(iterator);
                    _updateEditorWorklist();
                    Time.delay(0.5, function ():void {
                            _focusParameterEnvelope(_animatedParameterUids[0]);
                        });
                    onComplete();
                    _formReady = true;
                };
            
                _uiGenerator.generate(descriptor, configurationForm, wrapper, onChange);
            }
            
            // ---------
            // LISTENERS
            // ---------
            
            /**
             * Closest equivalent of a constructor function for MXML classes. Executed when
             * this component begins initializing; none of its children is available yet.
             */
            private function _onPreinitialize(event:FlexEvent):void {
                _windowBehavior = new WindowContentBehavior(this);
                _uiGenerator = new UiGenerator(UiFlexBuilder);
                SUBSCRIBE(EDITOR_SERVICE, _onEditorServiceNotice);
                SUBSCRIBE(EDITOR_FOCUS, _onEditorFocusNotice);
                SUBSCRIBE(INLINE_DOC_SHOW, _onInlineDocRequested);
                SUBSCRIBE(INLINE_DOC_HIDE, _onInlineDocDiscarded);
            }
            
            /**
             * Executed when this component has successfully initialized. At this stage,
             * its children are declared but not yet set up.
             */
            private function _onInitialize(event:FlexEvent):void {
            
                // Initialize the PresetManager
                presetManager.fileExtension = PRESET_FILE_EXTENSION;
                presetManager.homeDirName = PRESETS_HOME_DIR;
                presetManager.addEventListener(PresetEvent.PRESET_CHANGED, _onPresetChanged);
            }
            
            /**
             * Executed when this component has successfully initialized and set up, along with all its
             * children components.
             */
            private function _onCreationComplete(event:FlexEvent):void {
            
                // Setup initial window bounds. The Envelope Editor is hidden by default
                var winManager:IWindowsManager = _windowBehavior.manager;
                var windowUid:String = _windowBehavior.windowUid;
                if (winManager.isWindowAvailable(windowUid)) {
                    var bounds:Rectangle = Sizes.MIN_ADVANCED_GEN_CFG_WINDOW_BOUNDS;
                    winManager.updateWindowBounds(windowUid, bounds, false);
                    winManager.updateWindowMinSize(windowUid, bounds.width, bounds.height, true);
                    var mainScreenInfo:Object = ScreenUtils.getScreensInfo()[0];
                    if (mainScreenInfo) {
                        winManager.alignWindowToScreen(windowUid, mainScreenInfo.uid, 0.5, 0.5);
                    }
                }
            }
            
            /**
             * Executed when the window hosting this UIComponent is about to be closed.
             */
            private function _onWindowClosing(...ignore):void {
                _discardChanges();
                _closeWindow();
            }
            
            /**
             * Executed when the "learn more..." button is clicked. Causes the system browser to
             * load related documentation.
             */
            private function _onDocButtonClicked(event:MouseEvent):void {
                // TBD
            
                // var payload:Object = {};
                // payload[PARAM_UID] = _parameterUid;
                // payload[URL] = _documentationUrl;
                // SEND(DOCUMENTATION, payload);
            }
            
            /**
             * Executed when the "Apply" button is clicked.
             */
            private function _onApplyButtonClick(event:Event):void {
                _commitChanges();
            }
            
            /**
             * Executed when user clicks on the "Animate" checkbox inside the dedicated UI
             * section of a specific parameter. The exact action depends on the "tweeningStatus"
             * property contained by the received `info` Object.
             *
             * - if "tweeningStatus" is `true`, the editor is opened (if it was not already open),
             *   the parameter is added to the editor's worklist, and focused. Any subsequent change
             *   inside the editor, made to the parameter's associated envelope will be reflected in
             *   the parameter's `value`;
             *
             * - if "tweeningStatus" is `false`, and no other parameter requires the editor's
             *   services, the editor is closed; otherwise, it is left open. Any previous change
             *   made inside the editor, to the parameter's associated envelope will be lost, as
             *   all values on the envelope except the first one wil be removed. The first value
             *   will become the parameter's (constant) value, and will be reflected by the slider
             *   control that will be displayed once "animate" is disengaged for that parameter.
             */
            private function _onEditorServiceNotice(info:Object):void {
                var id:String = (info[PARAM_UID] as String);
                var tweeningEngaged:Boolean = (info[TWEENING_STATUS] as Boolean);
                if (tweeningEngaged) {
                    _engageTweeningFor(id);
                    _focusParameterEnvelope(id);
                }
                else {
                    _disengageTweeningFor(id);
                }
            }
            
            /**
             * Executed when the user interacts with a parameter inside the Envelope Editor in
             * other ways than by altering its envelope points.
             */
            private function _onParameterChange(event:ParameterChangeEvent):void {
            
                // The "active" parameter has been changed inside the editor
                if (event.type == ParameterChangeEvent.PARAMETER_CHANGE) {
                    _activeParamUid = event.data[DATA_ITEM][PARAM_UID] as String;
                }
            }
            
            /**
             * Executed when the user changes the color of a parameter inside the envelopes editor.
             */
            private function _onParameterColorChange(event:ParameterChangeEvent):void {
                var payload:Object = event.data.dataItem;
                var paramId:String = (payload.paramUid as String);
                var paramColor:uint = (payload.color as uint);
                var parameter:IParameter = _parameters.getByUid(paramId);
                if (parameter) {
                    parameter.color = paramColor;
                    var renderer:ParameterUI = (_uiGenerator.getComponentByName(paramId) as ParameterUI);
                    if (renderer) {
                        renderer.color = paramColor;
                    }
                }
            }
            
            /**
             * Executed when the user alters a parameter's envelope (e.g., by
             * adding, removing or dragging nodes.
             */
            private function _onNodesChange(event:ParameterChangeEvent):void {
            
                // The envelope corresponding to the "Active" parameter has been changed
                // inside the editor parameter (e.g., by adding, removing or dragging nodes).
                if (event.type == ParameterChangeEvent.NODES_CHANGE) {
                    var nodesSnapshot:Array = (event.data[DATA_ITEM] as Array);
                    if (nodesSnapshot && _activeParamUid && (_activeParamUid in _animatedParameters)) {
                        var parameter:IParameter = _parameters.getByUid(_activeParamUid);
                        if (parameter) {
                            var payload:Array = parameter.payload as Array;
            
                            // Update the parameter's values based on edited nodes
                            payload.length = 0;
                            for (var i:int = 0; i < nodesSnapshot.length; i++) {
                                var nodeInfo:Object = nodesSnapshot[i];
                                payload[nodeInfo[NODE_TIME]] = nodeInfo[NODE_AMPLITUDE];
                            }
            
                            // Propagate the new node values to the Preset Manager (so that it can
                            // decide whether they match a known preset or not)
                            _respondToSettingUpdate(parameter.name, payload);
            
                            // Update the related renderer, so that its "envelope proxy" shows the
                            // modified envelope
                            var renderer:ParameterUI = (_uiGenerator.getComponentByName(parameter.uid) as ParameterUI);
                            if (renderer) {
                                renderer.value = payload;
                            }
            
                            // Update the current dataset and trigger the window's internal status evaluator
                            // (to enable or disable the "apply"/"revert" buttons based on whether the new node
                            // values represent a change or not.
                            _currentDataset.setContent(parameter.name, payload);
                        }
                    }
                }
            }
            
            /**
             * Executed when user toggles on the "inline documentation" button inside of a parameter
             * tile. Opens associated parameter description.
             */
            private function _onInlineDocRequested(info:Object):void {
                _inlineDocTitle = info[PARAM_NAME] || null;
                _inlineDocBody = info[DESCRIPTION] || null;
                _inlineDocUrl = info[URL] || null;
            };
            
            /**
             * Executed when user toggles off the "inline documentation" button inside of a parameter
             * tile. Hides the associated parameter description, if open
             */
            private function _onInlineDocDiscarded(info:Object):void {
                trace('--> _onInlineDocDiscarded() called; info is: ' + JSON.stringify(info));
                _inlineDocTitle = null;
                _inlineDocBody = null;
                _inlineDocUrl = null;
            };
            
            /**
             * Executed when user clicks on the envelope shaped button displayed in place of the slider
             * control, while "animate" is selected for a certain parameter. Focuses the parameter's
             * associated envelope inside the editor.
             */
            private function _onEditorFocusNotice(info:Object):void {
                var id:String = (info[PARAM_UID] as String);
                _focusParameterEnvelope(id);
            }
            
            /**
             * Executed when a new preset has been loaded inside the PresetManager.
             * Updates the current settings to match the selected preset.
             */
            private function _onPresetChanged(event:PresetEvent):void {
                var presetSettings:Object = event.data;
                if (presetSettings) {
                    _writeCurrentSettings(presetSettings);
            
                    // We need to re-read current settings, or else, presets based on another preset
                    // will only contain the delta (differences to the original setting, and not the whole
                    // set). We could also re-read the settings on each value being changed by the user, but
                    // that would be too expensive.
                    _currentSettings = _readCurrentSettings();
                }
            }
            
            /**
             * Executed when all needed UI controls have been generated.
             */
            private function _onFormReady():void {
                if (!_currentSettings) {
                    _currentSettings = _readCurrentSettings();
                }
                presetManager.evaluate(_currentSettings);
            }
            
            /**
             * Executed when user changes a value inside one of the generated UI
             * controls.
             *
             * @param    key
             *            The UID the generated UI control is bound to.
             *
             * @param    value
             *            The new (modified) value inside the generated UI control.
             */
            private function _onValueChanged(key:String, value:Object):void {
                var parameter:IParameter = _parameters.getByUid(key);
                if (parameter) {
                    parameter.payload = value;
                    var parName:String = parameter.name;
                    _respondToSettingUpdate(parName, value);
                    _currentDataset.setContent(parName, value);
                }
            }
        ]]>
    </fx:Script>

    <!-- Loading notice -->
    <mx:Label width="100%"
              textAlign="center"
              text="Loading parameters..."
              visible="{!_formReady}"
              verticalCenter="0"
              horizontalCenter="0"/>

    <!-- BODY -->
    <s:Group id="bodyContainer"
             x="0"
             y="0"
             width="{width}"
             height="{rule.y - SPACE}">
        <s:layout>
            <s:HorizontalLayout
                                gap="{SPACE * 2}"
                                verticalAlign="top"
                                paddingLeft="{SPACE}"
                                paddingTop="{SPACE}"
                                paddingRight="{SPACE}"/>
        </s:layout>

        <!-- Left Pane. Presets manager and list of parameters -->
        <s:Group height="100%"
                 width="{ _envelopeEditorVisible? (bodyContainer.width - SPACE * 4) * 0.4 : bodyContainer.width - SPACE * 2 }">
            <s:layout>
                <s:VerticalLayout gap="{2 * SPACE}"
                                  horizontalAlign="left"
                                  paddingLeft="{SPACE}"
                                  paddingRight="{SPACE}"/>
            </s:layout>

            <!-- Preset manager -->
            <ui:PresetManagerUi id="presetManager"
                                width="{(bodyContainer.width - SPACE * 4) * 0.4}"
                                minHeight="110"
                                visible="{_formReady}"/>

            <!-- Parameters list label -->
            <mx:Label id="parametersListLabel"
                      text="Parameters"
                      fontWeight="bold"
                      visible="{_formReady}"/>

            <!-- Negative spacer to "consume" the vertical space between the label and the list -->
            <s:Group height="{SPACE * -3}"/>

            <!-- Parameters list -->
            <s:Group width="100%"
                     height="{rule.y - rule.height - presetManager.height - parametersListLabel.height - SPACE * 5}"
                     visible="{_formReady}">

                <s:Scroller width="100%" height="100%" horizontalScrollPolicy="off"
                            measuredSizeIncludesScrollBars="true">
                    <s:Group id="configurationForm">
                        <s:layout>
                            <s:TileLayout
                                          paddingTop="{SPACE}"
                                          paddingRight="{SPACE}"
                                          paddingBottom="{SPACE}"
                                          horizontalGap="{_envelopeEditorVisible? SPACE * 1.5 : SPACE * 2}"
                                          verticalGap="{SPACE * 5}"
                                          columnWidth="{COLUMN_WIDTH * 0.9 }"
                                          columnAlign="justifyUsingWidth"
                                          />
                        </s:layout>
                    </s:Group>
                </s:Scroller>
            </s:Group>
            <!-- End of parameters list -->
        </s:Group>
        <!-- End of left pane -->

        <!-- Right Pane. Parameters graphical editor -->
        <components:ParametersGraphicalEditor
                                              id="parametersEditor"
                                              width="{ (bodyContainer.width - SPACE * 4) * 0.6 }"
                                              height="100%"
                                              visible="{_envelopeEditorVisible}"
                                              includeInLayout="{_envelopeEditorVisible}"
                                              parameterChange="_onParameterChange(event)"
                                              colorChange="_onParameterColorChange(event)"
                                              nodesChange="_onNodesChange(event)"/>
    </s:Group>

    <!-- FOOTER -->
    <!-- Commit / Discard buttons -->
    <mx:HRule id="rule"
              width="{width - SPACE * 2}"
              x="{SPACE}"
              y="{bottomBox.y - rule.height - SPACE}"/>

    <mx:VBox horizontalScrollPolicy="off"
             id="bottomBox"
             paddingBottom="15"
             paddingLeft="15"
             paddingRight="15"
             paddingTop="5"
             verticalScrollPolicy="off"
             width="{width}"
             x="0"
             y="{height - bottomBox.height}">

        <mx:HBox horizontalScrollPolicy="off"
                 verticalScrollPolicy="off"
                 verticalAlign="middle"
                 horizontalAlign="center"
                 width="100%">

            <!-- Apply button -->
            <mx:Button click="_onApplyButtonClick (event)"
                       id="applyButton"
                       label="Apply configuration"/>
        </mx:HBox>
    </mx:VBox>

    <!-- DOCUMENTATION POP-UP -->
    <mx:VBox width="100%"
             horizontalCenter="0"
             backgroundColor="{Colors.INFORMATION}"
             horizontalAlign="left"
             verticalGap="{Sizes.LARGE_GAP}"
             paddingTop="{Sizes.HUGE_GAP}" paddingBottom="{Sizes.HUGE_GAP}"
             paddingLeft="{Sizes.HUGE_GAP * 2}" paddingRight="{Sizes.HUGE_GAP * 2}"
             visible="{_inlineDocTitle || _inlineDocBody || _inlineDocUrl}"
             horizontalScrollPolicy="off"
             verticalScrollPolicy="off">

        <!-- Related Parameter Name -->
        <mx:Label text="{_inlineDocTitle}" width="100%"
                  fontWeight="bold"
                  color="{Colors.UI_WHITE}"
                  visible="{!!_inlineDocTitle}"
                  includeInLayout="{!!_inlineDocTitle}"
                  textAlign="left"
                  paddingTop="0"
                  paddingLeft="0"
                  paddingRight="0"
                  paddingBottom="0"/>

        <!-- Description -->
        <mx:Text text="{_inlineDocBody}" width="100%"
                 color="{Colors.UI_WHITE}"
                 visible="{!!_inlineDocBody}"
                 includeInLayout="{!!_inlineDocBody}"
                 textAlign="left"
                 letterSpacing="0.5"
                 paddingTop="0"
                 paddingLeft="0"
                 paddingRight="0"
                 paddingBottom="0"/>

        <!-- "Read more" Button -->
        <mx:LinkButton label="Read more...  ¤"
                       color="{Colors.PRIMARY_COLOR}"
                       visible="{!!_inlineDocUrl}"
                       includeInLayout="{!!_inlineDocUrl}"
                       paddingLeft="0"
                       paddingTop="0"
                       click="_onDocButtonClicked (event)"
                       useHandCursor="true"
                       buttonMode="true"/>
    </mx:VBox>

</mx:Canvas>